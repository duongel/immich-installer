#!/usr/bin/env python3
import sys
import os
import subprocess
import threading
import secrets
import time
import urllib.request

# Check for tkinter dependency explicitly to avoid silent crashes
try:
    import tkinter as tk
    from tkinter import filedialog, messagebox, scrolledtext
except ImportError:
    print("ERROR: 'tkinter' is missing.")
    print("Please install it by running: sudo apt install python3-tk -y")
    sys.exit(1)

# --- Configuration & Templates ---

DOCKER_COMPOSE_TEMPLATE = """
name: immich

networks:
  immich_internal:
    driver: bridge
    internal: true  # No internet access for backend services
  immich_public:
    driver: bridge

services:
  immich-server:
    container_name: immich_server
    image: ghcr.io/immich-app/immich-server:release
    command: ['start.sh', 'immich']
    volumes:
      - {PHOTOS_PATH}:/usr/src/app/upload
      - {EXTERNAL_LIB_PATH}:{EXTERNAL_LIB_PATH}:ro
      - /etc/localtime:/etc/localtime:ro
    env_file:
      - .env
    ports:
      - 2283:2283
    depends_on:
      - redis
      - database
    restart: always
    networks:
      - immich_internal
      - immich_public

  immich-machine-learning:
    container_name: immich_machine_learning
    image: ghcr.io/immich-app/immich-machine-learning:release
    volumes:
      - model-cache:/cache
    env_file:
      - .env
    restart: always
    networks:
      - immich_internal

  redis:
    container_name: immich_redis
    image: redis:6.2-alpine
    restart: always
    networks:
      - immich_internal

  database:
    container_name: immich_postgres
    image: tensorchord/pgvecto-rs:pg14-v0.2.0
    environment:
      POSTGRES_PASSWORD: {DB_PASSWORD}
      POSTGRES_USER: postgres
      POSTGRES_DB: immich
      POSTGRES_INITDB_ARGS: '--data-checksums'
    volumes:
      - {INSTALL_PATH}/postgres:/var/lib/postgresql/data
    restart: always
    networks:
      - immich_internal

volumes:
  model-cache:
"""

ENV_TEMPLATE = """
# Auto-generated by Installer
# FORCE BIND TO ALL INTERFACES (Fixes connection issues)
HOST=0.0.0.0

UPLOAD_LOCATION={PHOTOS_PATH}
IMMICH_MACHINE_LEARNING_URL=http://immich-machine-learning:3003
DB_PASSWORD={DB_PASSWORD}
DB_HOSTNAME=immich_postgres
DB_USERNAME=postgres
DB_DATABASE_NAME=immich
REDIS_HOSTNAME=immich_redis
"""

class ImmichInstallerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Immich Installer for Raspberry Pi")
        self.root.geometry("600x800")  # Increased height for new checkbox

        # Variables
        self.root_pass = tk.StringVar()
        self.install_path = tk.StringVar()
        self.photos_path = tk.StringVar()
        self.ext_lib_path = tk.StringVar()
        self.stop_existing_var = tk.BooleanVar(value=True)  # Default: checked

        self._build_ui()

    def _build_ui(self):
        pad_opts = {'padx': 10, 'pady': 2}
        
        # Header
        tk.Label(self.root, text="Immich Auto-Installer", font=("Arial", 16, "bold")).pack(pady=15)

        # 1. Root Password
        frame1 = tk.Frame(self.root)
        frame1.pack(fill='x', padx=10, pady=5)
        tk.Label(frame1, text="Root Password (sudo):", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame1, textvariable=self.root_pass, show="*").pack(side='left', fill='x', expand=True)
        # Hint 1
        tk.Label(self.root, text="Required to install Docker and system services.", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=10).pack() # Spacer

        # 2. Install Path
        frame2 = tk.Frame(self.root)
        frame2.pack(fill='x', padx=10, pady=5)
        tk.Label(frame2, text="Where to install Immich:", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame2, textvariable=self.install_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame2, text="Browse", command=lambda: self.browse_dir(self.install_path)).pack(side='left', padx=5)
        # Hint 2
        tk.Label(self.root, text="Absolute path, e.g. /home/<username>/immich", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=10).pack() # Spacer

        # 3. Photos Path
        frame3 = tk.Frame(self.root)
        frame3.pack(fill='x', padx=10, pady=5)
        tk.Label(frame3, text="Where to store photo files:", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame3, textvariable=self.photos_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame3, text="Browse", command=lambda: self.browse_dir(self.photos_path)).pack(side='left', padx=5)
        # Hint 3
        tk.Label(self.root, text="Absolute path, e.g. /mnt/external_drive/photos", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=10).pack() # Spacer

        # 4. External Library
        frame4 = tk.Frame(self.root)
        frame4.pack(fill='x', padx=10, pady=5)
        tk.Label(frame4, text="External Library Path:", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame4, textvariable=self.ext_lib_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame4, text="Browse", command=lambda: self.browse_dir(self.ext_lib_path)).pack(side='left', padx=5)
        # Hint 4
        tk.Label(self.root, text="Absolute path, e.g. /mnt/nas/photos", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=15).pack() # Spacer

        # 5. Checkbox to stop existing Immich instances
        stop_frame = tk.Frame(self.root)
        stop_frame.pack(fill='x', padx=10, pady=5)
        
        stop_existing_check = tk.Checkbutton(
            stop_frame, 
            text='Stop existing Immich instances before installation',
            variable=self.stop_existing_var,
            font=('Arial', 10, 'bold')
        )
        stop_existing_check.pack(anchor='w')
        
        # Info label for checkbox
        info_label = tk.Label(
            stop_frame,
            text='Recommended: Prevents port conflicts by stopping all running Immich containers',
            font=('Arial', 9),
            fg='#666666',
            wraplength=550,
            justify=tk.LEFT
        )
        info_label.pack(anchor='w', padx=25)

        # Install Button
        self.btn_install = tk.Button(self.root, text="INSTALL IMMICH", bg="green", fg="white", font=("Arial", 12, "bold"), command=self.start_install)
        self.btn_install.pack(pady=25, ipadx=20)

        # Log Window
        tk.Label(self.root, text="Installation Log:").pack(anchor='w', padx=10)
        self.log_area = scrolledtext.ScrolledText(self.root, height=12, state='disabled')
        self.log_area.pack(fill='both', expand=True, padx=10, pady=(0, 10))

    def browse_dir(self, var):
        directory = filedialog.askdirectory()
        if directory:
            var.set(directory)

    def log(self, message):
        """Thread-safe logging to the text area"""
        def _log():
            self.log_area.configure(state='normal')
            self.log_area.insert(tk.END, str(message).strip() + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state='disabled')
        self.root.after(0, _log)

    def run_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and waits for result (no streaming)."""
        try:
            if sudo_pw:
                cmd_str = f"echo '{sudo_pw}' | sudo -S {cmd}"
                process = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            else:
                process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                raise Exception(f"Command failed: {cmd}\nError: {stderr}")
            return stdout
        except Exception as e:
            raise e

    def run_live_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and streams output to log window line-by-line."""
        try:
            full_cmd = cmd
            if sudo_pw:
                full_cmd = f"echo '{sudo_pw}' | sudo -S {cmd}"
            
            # Merge stderr into stdout to capture Docker progress
            process = subprocess.Popen(
                full_cmd, 
                shell=True, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.STDOUT, 
                text=True, 
                cwd=cwd,
                bufsize=1
            )

            # Read output stream
            for line in process.stdout:
                self.log(line)
            
            process.wait()
            if process.returncode != 0:
                raise Exception(f"Command failed: {cmd}")

        except Exception as e:
            raise e

    def stop_existing_immich(self, sudo_pw):
        """Stop all running Immich containers"""
        try:
            self.log("Checking for existing Immich containers...")
            
            # Find all running containers with 'immich' in the name
            result = self.run_command("docker ps -q --filter name=immich", sudo_pw=sudo_pw)
            
            if result.strip():
                container_ids = result.strip().split('\n')
                self.log(f"Found {len(container_ids)} running Immich container(s)")
                
                # Stop containers
                self.log("Stopping existing Immich containers...")
                self.run_command(f"docker container stop {' '.join(container_ids)}", sudo_pw=sudo_pw)
                self.log("Existing Immich containers stopped successfully")
                
                # Optional: Remove stopped containers
                self.log("Removing stopped Immich containers...")
                self.run_command(f"docker container rm {' '.join(container_ids)}", sudo_pw=sudo_pw)
                self.log("Stopped containers removed")
            else:
                self.log("No existing Immich containers found")
                
        except Exception as e:
            # Log warning but don't fail installation
            self.log(f"Warning: Could not stop existing containers: {e}")
            self.log("Continuing with installation...")

    def install_logic(self):
        pw = self.root_pass.get()
        inst_path = self.install_path.get()
        p_path = self.photos_path.get()
        ext_path = self.ext_lib_path.get()

        if not all([pw, inst_path, p_path, ext_path]):
            messagebox.showerror("Error", "All fields are required.")
            self.btn_install.config(state='normal')
            return

        try:
            # 1. Check Docker
            self.log("Checking for Docker...")
            docker_installed = False
            try:
                self.run_command("docker --version")
                self.log("Docker is already installed.")
                docker_installed = True
            except:
                self.log("Docker not found. Installing...")
                
                # --- Docker Install ---
                self.log("Downloading Docker installation script...")
                try:
                    urllib.request.urlretrieve("https://get.docker.com", "get-docker.sh")
                except Exception as e:
                    raise Exception(f"Failed to download Docker script: {e}")

                self.log("Running Docker installer...")
                self.run_command("sh get-docker.sh", sudo_pw=pw)
                self.log("Docker installed successfully.")
                docker_installed = True
            
            # ALWAYS ensure user is in the docker group (even if docker was already installed)
            if docker_installed:
                user = os.getenv('USER')
                self.log(f"Ensuring {user} is in 'docker' group...")
                try:
                    self.run_command(f"usermod -aG docker {user}", sudo_pw=pw)
                except Exception as e:
                    self.log(f"Warning: Could not add user to group: {e}")

            # 1.5. Stop existing Immich instances if checkbox is checked
            if self.stop_existing_var.get():
                self.log("-----------------------------------------")
                self.stop_existing_immich(pw)
                self.log("-----------------------------------------")

            # Ensure Install Directory exists
            if not os.path.exists(inst_path):
                os.makedirs(inst_path)

            # 2. Generate Credentials & Config
            db_password = secrets.token_urlsafe(16)
            
            # 3. Create docker-compose.yml
            compose_content = DOCKER_COMPOSE_TEMPLATE.format(
                PHOTOS_PATH=p_path,
                EXTERNAL_LIB_PATH=ext_path,
                DB_PASSWORD=db_password,
                INSTALL_PATH=inst_path
            )

            # 4. Create .env file
            env_content = ENV_TEMPLATE.format(
                PHOTOS_PATH=p_path,
                DB_PASSWORD=db_password
            )

            self.log(f"Writing configuration files to {inst_path}...")
            
            with open(os.path.join(inst_path, "docker-compose.yml"), "w") as f:
                f.write(compose_content)
            
            with open(os.path.join(inst_path, ".env"), "w") as f:
                f.write(env_content)

            # 5. Pull Images (with logging)
            self.log("-----------------------------------------")
            self.log("Downloading Immich Images...")
            self.log("This may take a while. Please wait...")
            
            # We explicitly pull first to show the download logs
            self.run_live_command("docker compose pull", sudo_pw=pw, cwd=inst_path)
            
            # 6. Start Immich
            self.log("-----------------------------------------")
            self.log("Starting Immich containers...")
            self.run_live_command("docker compose up -d", sudo_pw=pw, cwd=inst_path)

            self.log("-----------------------------------------")
            self.log("SUCCESS! Immich is starting up.")
            self.log("Access Immich at: http://<YOUR_PI_IP>:2283")
            self.log("-----------------------------------------")
            self.log("NOTE: To run 'docker' commands without sudo later,")
            self.log("you MUST reboot your Raspberry Pi or log out/in.")
            self.log("-----------------------------------------")
            messagebox.showinfo("Success", "Immich Installed!\n\nPlease reboot your system to finalize Docker permissions.")

        except Exception as e:
            self.log(f"ERROR: {str(e)}")
            messagebox.showerror("Installation Failed", str(e))
        finally:
            self.btn_install.config(state='normal')
            if os.path.exists("get-docker.sh"):
                os.remove("get-docker.sh")

    def start_install(self):
        self.btn_install.config(state='disabled')
        threading.Thread(target=self.install_logic, daemon=True).start()

if __name__ == "__main__":
    root = tk.Tk()
    app = ImmichInstallerApp(root)
    root.mainloop()
