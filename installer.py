#!/usr/bin/env python3
import sys
import os
import subprocess
import threading
import secrets
import time
import urllib.request
import shutil

# Check for tkinter dependency explicitly to avoid silent crashes
try:
    import tkinter as tk
    from tkinter import filedialog, messagebox, scrolledtext
except ImportError:
    print("ERROR: 'tkinter' is missing.")
    print("Please install it by running: sudo apt install python3-tk -y")
    sys.exit(1)

# --- Configuration & Templates ---

DOCKER_COMPOSE_TEMPLATE = """
name: immich

networks:
  immich_internal:
    driver: bridge
    internal: true  # No internet access for backend services
  immich_public:
    driver: bridge

services:
  immich-server:
    container_name: immich_server
    image: ghcr.io/immich-app/immich-server:release
    command: ['start.sh', 'immich']
    volumes:
      - {PHOTOS_PATH}:/usr/src/app/upload
      - {EXTERNAL_LIB_PATH}:{EXTERNAL_LIB_PATH}:ro
      - /etc/localtime:/etc/localtime:ro
    env_file:
      - .env
    ports:
      - 2283:2283
    depends_on:
      - redis
      - database
    restart: always
    networks:
      - immich_internal
      - immich_public

  immich-machine-learning:
    container_name: immich_machine_learning
    image: ghcr.io/immich-app/immich-machine-learning:release
    volumes:
      - model-cache:/cache
    env_file:
      - .env
    restart: always
    networks:
      - immich_internal

  redis:
    container_name: immich_redis
    image: redis:6.2-alpine
    restart: always
    networks:
      - immich_internal

  database:
    container_name: immich_postgres
    image: tensorchord/pgvecto-rs:pg14-v0.2.0
    environment:
      POSTGRES_PASSWORD: {DB_PASSWORD}
      POSTGRES_USER: postgres
      POSTGRES_DB: immich
      POSTGRES_INITDB_ARGS: '--data-checksums'
    volumes:
      - {INSTALL_PATH}/postgres:/var/lib/postgresql/data
    restart: always
    networks:
      - immich_internal

volumes:
  model-cache:
"""

ENV_TEMPLATE = """
# Auto-generated by Installer
# FORCE BIND TO ALL INTERFACES (Fixes connection issues)
HOST=0.0.0.0

UPLOAD_LOCATION={PHOTOS_PATH}
IMMICH_MACHINE_LEARNING_URL=http://immich-machine-learning:3003
DB_PASSWORD={DB_PASSWORD}
DB_HOSTNAME=immich_postgres
DB_USERNAME=postgres
DB_DATABASE_NAME=immich
REDIS_HOSTNAME=immich_redis
"""

class ImmichInstallerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Immich Installer for Raspberry Pi")
        self.root.geometry("600x800")  # Increased height for new checkbox

        # Variables
        self.root_pass = tk.StringVar()
        self.install_path = tk.StringVar()
        self.photos_path = tk.StringVar()
        self.ext_lib_path = tk.StringVar()
        self.stop_existing_var = tk.BooleanVar(value=True)  # Default: checked

        self._build_ui()

    def _build_ui(self):
        pad_opts = {'padx': 10, 'pady': 2}
        
        # Header
        tk.Label(self.root, text="Immich Auto-Installer", font=("Arial", 16, "bold")).pack(pady=15)

        # 1. Root Password
        frame1 = tk.Frame(self.root)
        frame1.pack(fill='x', padx=10, pady=5)
        tk.Label(frame1, text="Root Password (sudo):", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame1, textvariable=self.root_pass, show="*").pack(side='left', fill='x', expand=True)
        # Hint 1
        tk.Label(self.root, text="Required to install Docker and system services.", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=10).pack() # Spacer

        # 2. Install Path
        frame2 = tk.Frame(self.root)
        frame2.pack(fill='x', padx=10, pady=5)
        tk.Label(frame2, text="Where to install Immich:", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame2, textvariable=self.install_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame2, text="Browse", command=lambda: self.browse_dir(self.install_path)).pack(side='left', padx=5)
        # Hint 2
        tk.Label(self.root, text="Absolute path, e.g. /home/<username>/immich", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=10).pack() # Spacer

        # 3. Photos Path
        frame3 = tk.Frame(self.root)
        frame3.pack(fill='x', padx=10, pady=5)
        tk.Label(frame3, text="Where to store photo files:", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame3, textvariable=self.photos_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame3, text="Browse", command=lambda: self.browse_dir(self.photos_path)).pack(side='left', padx=5)
        # Hint 3
        tk.Label(self.root, text="Absolute path, e.g. /mnt/external_drive/photos", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=10).pack() # Spacer

        # 4. External Library
        frame4 = tk.Frame(self.root)
        frame4.pack(fill='x', padx=10, pady=5)
        tk.Label(frame4, text="External Library Path:", width=25, anchor='w', font=("Arial", 10, "bold")).pack(side='left')
        tk.Entry(frame4, textvariable=self.ext_lib_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame4, text="Browse", command=lambda: self.browse_dir(self.ext_lib_path)).pack(side='left', padx=5)
        # Hint 4
        tk.Label(self.root, text="Absolute path, e.g. /mnt/nas/photos", 
                 fg="gray", font=("Arial", 9)).pack(anchor='w', padx=10)

        tk.Frame(self.root, height=15).pack() # Spacer

        # 5. Checkbox to stop existing Immich instances
        stop_frame = tk.Frame(self.root)
        stop_frame.pack(fill='x', padx=10, pady=5)
        
        stop_existing_check = tk.Checkbutton(
            stop_frame, 
            text='⚠️ Completely remove existing Immich instances (including database)',
            variable=self.stop_existing_var,
            font=('Arial', 10, 'bold')
        )
        stop_existing_check.pack(anchor='w')
        
        # Info label for checkbox
        info_label = tk.Label(
            stop_frame,
            text='WARNING: This will delete ALL containers, volumes, networks, database data, and installation folders',
            font=('Arial', 9),
            fg='#CC0000',
            wraplength=550,
            justify=tk.LEFT
        )
        info_label.pack(anchor='w', padx=25)

        # Install Button
        self.btn_install = tk.Button(self.root, text="INSTALL IMMICH", bg="green", fg="white", font=("Arial", 12, "bold"), command=self.start_install)
        self.btn_install.pack(pady=25, ipadx=20)

        # Log Window
        tk.Label(self.root, text="Installation Log:").pack(anchor='w', padx=10)
        self.log_area = scrolledtext.ScrolledText(self.root, height=12, state='disabled')
        self.log_area.pack(fill='both', expand=True, padx=10, pady=(0, 10))

    def browse_dir(self, var):
        directory = filedialog.askdirectory()
        if directory:
            var.set(directory)

    def log(self, message):
        """Thread-safe logging to the text area"""
        def _log():
            self.log_area.configure(state='normal')
            self.log_area.insert(tk.END, str(message).strip() + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state='disabled')
        self.root.after(0, _log)

    def run_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and waits for result (no streaming)."""
        try:
            if sudo_pw:
                cmd_str = f"echo '{sudo_pw}' | sudo -S {cmd}"
                process = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            else:
                process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                raise Exception(f"Command failed: {cmd}\nError: {stderr}")
            return stdout
        except Exception as e:
            raise e

    def run_live_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and streams output to log window line-by-line."""
        try:
            full_cmd = cmd
            if sudo_pw:
                full_cmd = f"echo '{sudo_pw}' | sudo -S {cmd}"
            
            # Merge stderr into stdout to capture Docker progress
            process = subprocess.Popen(
                full_cmd, 
                shell=True, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.STDOUT, 
                text=True, 
                cwd=cwd,
                bufsize=1
            )

            # Read output stream
            for line in process.stdout:
                self.log(line)
            
            process.wait()
            if process.returncode != 0:
                raise Exception(f"Command failed: {cmd}")

        except Exception as e:
            raise e

    def find_immich_installations(self, sudo_pw):
        """Find all possible Immich installation directories"""
        self.log("Searching for existing Immich installations...")
        
        possible_locations = []
        
        # Method 1: Find docker-compose.yml files with 'immich' in them
        try:
            result = self.run_command(
                "find /home -name 'docker-compose.yml' -type f 2>/dev/null | xargs grep -l 'immich' 2>/dev/null || true",
                sudo_pw=sudo_pw
            )
            if result.strip():
                for compose_file in result.strip().split('\n'):
                    if compose_file:
                        install_dir = os.path.dirname(compose_file)
                        possible_locations.append(install_dir)
                        self.log(f"  Found: {install_dir}")
        except Exception as e:
            self.log(f"  Search method 1 skipped: {e}")
        
        # Method 2: Look for common installation paths
        common_paths = [
            "/home/*/immich",
            "/opt/immich",
            "/srv/immich",
            "/var/lib/immich"
        ]
        
        for pattern in common_paths:
            try:
                result = self.run_command(f"ls -d {pattern} 2>/dev/null || true", sudo_pw=sudo_pw)
                if result.strip():
                    for path in result.strip().split('\n'):
                        if path and path not in possible_locations:
                            possible_locations.append(path)
                            self.log(f"  Found: {path}")
            except:
                pass
        
        return possible_locations

    def completely_remove_immich(self, sudo_pw, inst_path):
        """Completely remove all Immich containers, volumes, networks, and data"""
        try:
            self.log("=" * 60)
            self.log("REMOVING EXISTING IMMICH INSTALLATION")
            self.log("=" * 60)
            
            # Step 1: Find all Immich installation directories
            installation_dirs = self.find_immich_installations(sudo_pw)
            
            # Step 2: Stop and remove containers using docker compose down
            self.log("\nStep 1: Stopping Immich using docker compose down...")
            for install_dir in installation_dirs:
                try:
                    compose_file = os.path.join(install_dir, "docker-compose.yml")
                    if os.path.exists(compose_file):
                        self.log(f"Running 'docker compose down -v' in {install_dir}...")
                        self.run_command("docker compose down -v --remove-orphans", sudo_pw=sudo_pw, cwd=install_dir)
                        self.log(f"✓ Stopped and removed containers from {install_dir}")
                except Exception as e:
                    self.log(f"Warning: Could not run docker compose down in {install_dir}: {e}")
            
            # Step 3: Force remove any remaining Immich containers
            self.log("\nStep 2: Force removing any remaining Immich containers...")
            try:
                result = self.run_command("docker ps -aq --filter name=immich", sudo_pw=sudo_pw)
                if result.strip():
                    container_ids = result.strip().split('\n')
                    self.log(f"Force removing {len(container_ids)} container(s)...")
                    self.run_command(f"docker rm -f {' '.join(container_ids)}", sudo_pw=sudo_pw)
                    self.log("✓ Containers force removed")
                else:
                    self.log("No remaining containers found")
            except Exception as e:
                self.log(f"Warning: {e}")
            
            # Step 4: Remove Immich Docker volumes
            self.log("\nStep 3: Removing Immich Docker volumes...")
            try:
                result = self.run_command("docker volume ls -q --filter name=immich", sudo_pw=sudo_pw)
                if result.strip():
                    volume_names = result.strip().split('\n')
                    self.log(f"Found {len(volume_names)} Docker volume(s):")
                    for vol in volume_names:
                        self.log(f"  - {vol}")
                    self.run_command(f"docker volume rm -f {' '.join(volume_names)}", sudo_pw=sudo_pw)
                    self.log("✓ Docker volumes removed")
                else:
                    self.log("No Immich Docker volumes found")
            except Exception as e:
                self.log(f"Warning: {e}")
            
            # Step 5: Remove Immich networks
            self.log("\nStep 4: Removing Immich networks...")
            try:
                result = self.run_command("docker network ls -q --filter name=immich", sudo_pw=sudo_pw)
                if result.strip():
                    network_ids = result.strip().split('\n')
                    self.log(f"Removing {len(network_ids)} network(s)...")
                    self.run_command(f"docker network rm {' '.join(network_ids)}", sudo_pw=sudo_pw)
                    self.log("✓ Networks removed")
                else:
                    self.log("No Immich networks found")
            except Exception as e:
                self.log(f"Warning: {e}")
            
            # Step 6: CRITICAL - Remove bind-mounted PostgreSQL data directories
            self.log("\nStep 5: Removing bind-mounted PostgreSQL data directories...")
            for install_dir in installation_dirs:
                postgres_dir = os.path.join(install_dir, "postgres")
                if os.path.exists(postgres_dir):
                    self.log(f"Deleting PostgreSQL data at: {postgres_dir}")
                    try:
                        # Use sudo to remove as postgres user may own these files
                        self.run_command(f"rm -rf '{postgres_dir}'", sudo_pw=sudo_pw)
                        self.log(f"✓ Deleted: {postgres_dir}")
                    except Exception as e:
                        self.log(f"Error deleting {postgres_dir}: {e}")
                        # Try with shutil as fallback
                        try:
                            shutil.rmtree(postgres_dir, ignore_errors=True)
                            self.log(f"✓ Deleted (fallback): {postgres_dir}")
                        except Exception as e2:
                            self.log(f"Could not delete {postgres_dir}: {e2}")
            
            # Step 7: Also check the new installation path
            if inst_path:
                postgres_dir = os.path.join(inst_path, "postgres")
                if os.path.exists(postgres_dir):
                    self.log(f"Deleting PostgreSQL data at new install path: {postgres_dir}")
                    try:
                        self.run_command(f"rm -rf '{postgres_dir}'", sudo_pw=sudo_pw)
                        self.log(f"✓ Deleted: {postgres_dir}")
                    except Exception as e:
                        try:
                            shutil.rmtree(postgres_dir, ignore_errors=True)
                            self.log(f"✓ Deleted (fallback): {postgres_dir}")
                        except:
                            self.log(f"Warning: Could not delete {postgres_dir}")
                
                # Also remove any leftover .env and docker-compose.yml
                for filename in ['.env', 'docker-compose.yml']:
                    filepath = os.path.join(inst_path, filename)
                    if os.path.exists(filepath):
                        try:
                            os.remove(filepath)
                            self.log(f"✓ Removed old {filename}")
                        except Exception as e:
                            self.log(f"Warning: Could not remove {filepath}: {e}")
            
            # Step 8: Clean up orphaned volumes
            self.log("\nStep 6: Cleaning up orphaned Docker volumes...")
            try:
                self.run_command("docker volume prune -f", sudo_pw=sudo_pw)
                self.log("✓ Orphaned volumes cleaned")
            except Exception as e:
                self.log(f"Warning: {e}")
            
            self.log("\n" + "=" * 60)
            self.log("✓ COMPLETE REMOVAL FINISHED")
            self.log("All Immich containers, volumes, networks, and data removed")
            self.log("Database will be created fresh with new password")
            self.log("=" * 60 + "\n")
                
        except Exception as e:
            self.log(f"ERROR during removal: {str(e)}")
            raise

    def install_logic(self):
        pw = self.root_pass.get()
        inst_path = self.install_path.get()
        p_path = self.photos_path.get()
        ext_path = self.ext_lib_path.get()

        if not all([pw, inst_path, p_path, ext_path]):
            messagebox.showerror("Error", "All fields are required.")
            self.btn_install.config(state='normal')
            return

        try:
            # 1. Check Docker
            self.log("Checking for Docker...")
            docker_installed = False
            try:
                self.run_command("docker --version")
                self.log("Docker is already installed.")
                docker_installed = True
            except:
                self.log("Docker not found. Installing...")
                
                # --- Docker Install ---
                self.log("Downloading Docker installation script...")
                try:
                    urllib.request.urlretrieve("https://get.docker.com", "get-docker.sh")
                except Exception as e:
                    raise Exception(f"Failed to download Docker script: {e}")

                self.log("Running Docker installer...")
                self.run_command("sh get-docker.sh", sudo_pw=pw)
                self.log("Docker installed successfully.")
                docker_installed = True
            
            # ALWAYS ensure user is in the docker group (even if docker was already installed)
            if docker_installed:
                user = os.getenv('USER')
                self.log(f"Ensuring {user} is in 'docker' group...")
                try:
                    self.run_command(f"usermod -aG docker {user}", sudo_pw=pw)
                except Exception as e:
                    self.log(f"Warning: Could not add user to group: {e}")

            # 1.5. Completely remove existing Immich if checkbox is checked
            if self.stop_existing_var.get():
                self.completely_remove_immich(pw, inst_path)

            # Ensure Install Directory exists
            if not os.path.exists(inst_path):
                os.makedirs(inst_path)
                self.log(f"Created installation directory: {inst_path}")

            # 2. Generate Credentials & Config
            db_password = secrets.token_urlsafe(16)
            self.log(f"Generated new database password: {db_password[:8]}... (truncated)")
            
            # 3. Create docker-compose.yml
            compose_content = DOCKER_COMPOSE_TEMPLATE.format(
                PHOTOS_PATH=p_path,
                EXTERNAL_LIB_PATH=ext_path,
                DB_PASSWORD=db_password,
                INSTALL_PATH=inst_path
            )

            # 4. Create .env file
            env_content = ENV_TEMPLATE.format(
                PHOTOS_PATH=p_path,
                DB_PASSWORD=db_password
            )

            self.log(f"Writing configuration files to {inst_path}...")
            
            with open(os.path.join(inst_path, "docker-compose.yml"), "w") as f:
                f.write(compose_content)
            
            with open(os.path.join(inst_path, ".env"), "w") as f:
                f.write(env_content)
            
            self.log("✓ Configuration files written")

            # 5. Pull Images (with logging)
            self.log("-----------------------------------------")
            self.log("Downloading Immich Images...")
            self.log("This may take a while. Please wait...")
            
            # We explicitly pull first to show the download logs
            self.run_live_command("docker compose pull", sudo_pw=pw, cwd=inst_path)
            
            # 6. Start Immich
            self.log("-----------------------------------------")
            self.log("Starting Immich containers...")
            self.run_live_command("docker compose up -d", sudo_pw=pw, cwd=inst_path)

            self.log("-----------------------------------------")
            self.log("SUCCESS! Immich is starting up.")
            self.log("Access Immich at: http://<YOUR_PI_IP>:2283")
            self.log("-----------------------------------------")
            self.log("NOTE: To run 'docker' commands without sudo later,")
            self.log("you MUST reboot your Raspberry Pi or log out/in.")
            self.log("-----------------------------------------")
            messagebox.showinfo("Success", "Immich Installed!\n\nPlease reboot your system to finalize Docker permissions.")

        except Exception as e:
            self.log(f"ERROR: {str(e)}")
            messagebox.showerror("Installation Failed", str(e))
        finally:
            self.btn_install.config(state='normal')
            if os.path.exists("get-docker.sh"):
                os.remove("get-docker.sh")

    def start_install(self):
        self.btn_install.config(state='disabled')
        threading.Thread(target=self.install_logic, daemon=True).start()

if __name__ == "__main__":
    root = tk.Tk()
    app = ImmichInstallerApp(root)
    root.mainloop()
