#!/usr/bin/env python3
import sys
import os
import subprocess
import threading
import secrets
import time
import urllib.request

# Check for tkinter dependency explicitly to avoid silent crashes
try:
    import tkinter as tk
    from tkinter import filedialog, messagebox, scrolledtext
except ImportError:
    print("ERROR: 'tkinter' is missing.")
    print("Please install it by running: sudo apt install python3-tk -y")
    sys.exit(1)

# --- Configuration & Templates ---

DOCKER_COMPOSE_TEMPLATE = """
name: immich

networks:
  immich_internal:
    driver: bridge
    internal: true  # No internet access for backend services
  immich_public:
    driver: bridge

services:
  immich-server:
    container_name: immich_server
    image: ghcr.io/immich-app/immich-server:release
    command: ['start.sh', 'immich']
    volumes:
      - {PHOTOS_PATH}:/usr/src/app/upload
      - {EXTERNAL_LIB_PATH}:/mnt/external_lib:ro
      - /etc/localtime:/etc/localtime:ro
    env_file:
      - .env
    ports:
      - 2283:2283
    depends_on:
      - redis
      - database
    restart: always
    networks:
      - immich_internal
      - immich_public

  immich-machine-learning:
    container_name: immich_machine_learning
    image: ghcr.io/immich-app/immich-machine-learning:release
    volumes:
      - model-cache:/cache
    env_file:
      - .env
    restart: always
    networks:
      - immich_internal

  redis:
    container_name: immich_redis
    image: redis:6.2-alpine
    restart: always
    networks:
      - immich_internal

  database:
    container_name: immich_postgres
    image: tensorchord/pgvecto-rs:pg14-v0.2.0
    environment:
      POSTGRES_PASSWORD: {DB_PASSWORD}
      POSTGRES_USER: postgres
      POSTGRES_DB: immich
      POSTGRES_INITDB_ARGS: '--data-checksums'
    volumes:
      - {INSTALL_PATH}/postgres:/var/lib/postgresql/data
    restart: always
    networks:
      - immich_internal

volumes:
  model-cache:
"""

ENV_TEMPLATE = """
# Auto-generated by Installer
# FORCE BIND TO ALL INTERFACES (Fixes connection issues)
HOST=0.0.0.0

UPLOAD_LOCATION={PHOTOS_PATH}
IMMICH_MACHINE_LEARNING_URL=http://immich-machine-learning:3003
DB_PASSWORD={DB_PASSWORD}
DB_HOSTNAME=immich_postgres
DB_USERNAME=postgres
DB_DATABASE_NAME=immich
REDIS_HOSTNAME=immich_redis
"""

class ImmichInstallerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Immich Installer for Raspberry Pi")
        self.root.geometry("600x650")

        # Variables
        self.root_pass = tk.StringVar()
        self.install_path = tk.StringVar()
        self.photos_path = tk.StringVar()
        self.ext_lib_path = tk.StringVar()

        self._build_ui()

    def _build_ui(self):
        pad_opts = {'padx': 10, 'pady': 5}
        
        # Header
        tk.Label(self.root, text="Immich Auto-Installer", font=("Arial", 16, "bold")).pack(pady=10)

        # 1. Root Password
        frame1 = tk.Frame(self.root)
        frame1.pack(fill='x', **pad_opts)
        tk.Label(frame1, text="1. Root Password (sudo):", width=25, anchor='w').pack(side='left')
        tk.Entry(frame1, textvariable=self.root_pass, show="*").pack(side='left', fill='x', expand=True)

        # 2. Install Path
        frame2 = tk.Frame(self.root)
        frame2.pack(fill='x', **pad_opts)
        tk.Label(frame2, text="2. Install Location (Config/DB):", width=25, anchor='w').pack(side='left')
        tk.Entry(frame2, textvariable=self.install_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame2, text="Browse", command=lambda: self.browse_dir(self.install_path)).pack(side='left', padx=5)

        # 3. Photos Path
        frame3 = tk.Frame(self.root)
        frame3.pack(fill='x', **pad_opts)
        tk.Label(frame3, text="3. Original Photos Storage:", width=25, anchor='w').pack(side='left')
        tk.Entry(frame3, textvariable=self.photos_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame3, text="Browse", command=lambda: self.browse_dir(self.photos_path)).pack(side='left', padx=5)

        # 4. External Library
        frame4 = tk.Frame(self.root)
        frame4.pack(fill='x', **pad_opts)
        tk.Label(frame4, text="4. External Library (HDD):", width=25, anchor='w').pack(side='left')
        tk.Entry(frame4, textvariable=self.ext_lib_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame4, text="Browse", command=lambda: self.browse_dir(self.ext_lib_path)).pack(side='left', padx=5)

        # Install Button
        self.btn_install = tk.Button(self.root, text="INSTALL IMMICH", bg="green", fg="white", font=("Arial", 12, "bold"), command=self.start_install)
        self.btn_install.pack(pady=20, ipadx=20)

        # Log Window
        tk.Label(self.root, text="Installation Log:").pack(anchor='w', padx=10)
        self.log_area = scrolledtext.ScrolledText(self.root, height=15, state='disabled')
        self.log_area.pack(fill='both', expand=True, padx=10, pady=10)

    def browse_dir(self, var):
        directory = filedialog.askdirectory()
        if directory:
            var.set(directory)

    def log(self, message):
        """Thread-safe logging to the text area"""
        def _log():
            self.log_area.configure(state='normal')
            self.log_area.insert(tk.END, str(message).strip() + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state='disabled')
        self.root.after(0, _log)

    def run_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and waits for result (no streaming)."""
        try:
            if sudo_pw:
                cmd_str = f"echo '{sudo_pw}' | sudo -S {cmd}"
                process = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            else:
                process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            
            stdout, stderr = process.communicate()
            
            if process.returncode !=