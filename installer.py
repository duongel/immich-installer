#!/usr/bin/env python3
import sys
import os
import subprocess
import threading
import secrets
import time
import urllib.request

# Check for tkinter dependency explicitly to avoid silent crashes
try:
    import tkinter as tk
    from tkinter import filedialog, messagebox, scrolledtext
except ImportError:
    print("ERROR: 'tkinter' is missing.")
    print("Please install it by running: sudo apt install python3-tk -y")
    sys.exit(1)

# --- Configuration & Templates ---

DOCKER_COMPOSE_TEMPLATE = """
name: immich

networks:
  immich_internal:
    driver: bridge
    internal: true  # No internet access for backend services
  immich_public:
    driver: bridge

services:
  immich-server:
    container_name: immich_server
    image: ghcr.io/immich-app/immich-server:release
    command: ['start.sh', 'immich']
    volumes:
      - {PHOTOS_PATH}:/usr/src/app/upload
      - {EXTERNAL_LIB_PATH}:/mnt/external_lib:ro
      - /etc/localtime:/etc/localtime:ro
    env_file:
      - .env
    ports:
      - 2283:2283
    depends_on:
      - redis
      - database
    restart: always
    networks:
      - immich_internal
      - immich_public

  immich-machine-learning:
    container_name: immich_machine_learning
    image: ghcr.io/immich-app/immich-machine-learning:release
    volumes:
      - model-cache:/cache
    env_file:
      - .env
    restart: always
    networks:
      - immich_internal

  redis:
    container_name: immich_redis
    image: redis:6.2-alpine
    restart: always
    networks:
      - immich_internal

  database:
    container_name: immich_postgres
    image: tensorchord/pgvecto-rs:pg14-v0.2.0
    environment:
      POSTGRES_PASSWORD: {DB_PASSWORD}
      POSTGRES_USER: postgres
      POSTGRES_DB: immich
      POSTGRES_INITDB_ARGS: '--data-checksums'
    volumes:
      - {INSTALL_PATH}/postgres:/var/lib/postgresql/data
    restart: always
    networks:
      - immich_internal

volumes:
  model-cache:
"""

ENV_TEMPLATE = """
# Auto-generated by Installer
# FORCE BIND TO ALL INTERFACES (Fixes connection issues)
HOST=0.0.0.0

UPLOAD_LOCATION={PHOTOS_PATH}
IMMICH_MACHINE_LEARNING_URL=http://immich-machine-learning:3003
DB_PASSWORD={DB_PASSWORD}
DB_HOSTNAME=immich_postgres
DB_USERNAME=postgres
DB_DATABASE_NAME=immich
REDIS_HOSTNAME=immich_redis
"""

class ImmichInstallerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Immich Installer for Raspberry Pi")
        self.root.geometry("600x650")

        # Variables
        self.root_pass = tk.StringVar()
        self.install_path = tk.StringVar()
        self.photos_path = tk.StringVar()
        self.ext_lib_path = tk.StringVar()

        self._build_ui()

    def _build_ui(self):
        pad_opts = {'padx': 10, 'pady': 5}
        
        # Header
        tk.Label(self.root, text="Immich Auto-Installer", font=("Arial", 16, "bold")).pack(pady=10)

        # 1. Root Password
        frame1 = tk.Frame(self.root)
        frame1.pack(fill='x', **pad_opts)
        tk.Label(frame1, text="1. Root Password (sudo):", width=25, anchor='w').pack(side='left')
        tk.Entry(frame1, textvariable=self.root_pass, show="*").pack(side='left', fill='x', expand=True)

        # 2. Install Path
        frame2 = tk.Frame(self.root)
        frame2.pack(fill='x', **pad_opts)
        tk.Label(frame2, text="2. Install Location (Config/DB):", width=25, anchor='w').pack(side='left')
        tk.Entry(frame2, textvariable=self.install_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame2, text="Browse", command=lambda: self.browse_dir(self.install_path)).pack(side='left', padx=5)

        # 3. Photos Path
        frame3 = tk.Frame(self.root)
        frame3.pack(fill='x', **pad_opts)
        tk.Label(frame3, text="3. Original Photos Storage:", width=25, anchor='w').pack(side='left')
        tk.Entry(frame3, textvariable=self.photos_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame3, text="Browse", command=lambda: self.browse_dir(self.photos_path)).pack(side='left', padx=5)

        # 4. External Library
        frame4 = tk.Frame(self.root)
        frame4.pack(fill='x', **pad_opts)
        tk.Label(frame4, text="4. External Library (HDD):", width=25, anchor='w').pack(side='left')
        tk.Entry(frame4, textvariable=self.ext_lib_path).pack(side='left', fill='x', expand=True)
        tk.Button(frame4, text="Browse", command=lambda: self.browse_dir(self.ext_lib_path)).pack(side='left', padx=5)

        # Install Button
        self.btn_install = tk.Button(self.root, text="INSTALL IMMICH", bg="green", fg="white", font=("Arial", 12, "bold"), command=self.start_install)
        self.btn_install.pack(pady=20, ipadx=20)

        # Log Window
        tk.Label(self.root, text="Installation Log:").pack(anchor='w', padx=10)
        self.log_area = scrolledtext.ScrolledText(self.root, height=15, state='disabled')
        self.log_area.pack(fill='both', expand=True, padx=10, pady=10)

    def browse_dir(self, var):
        directory = filedialog.askdirectory()
        if directory:
            var.set(directory)

    def log(self, message):
        """Thread-safe logging to the text area"""
        def _log():
            self.log_area.configure(state='normal')
            self.log_area.insert(tk.END, str(message).strip() + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state='disabled')
        self.root.after(0, _log)

    def run_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and waits for result (no streaming)."""
        try:
            if sudo_pw:
                cmd_str = f"echo '{sudo_pw}' | sudo -S {cmd}"
                process = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            else:
                process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, cwd=cwd)
            
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                raise Exception(f"Command failed: {cmd}\nError: {stderr}")
            return stdout
        except Exception as e:
            raise e

    def run_live_command(self, cmd, sudo_pw=None, cwd=None):
        """Runs shell command and streams output to log window line-by-line."""
        try:
            full_cmd = cmd
            if sudo_pw:
                full_cmd = f"echo '{sudo_pw}' | sudo -S {cmd}"
            
            # Merge stderr into stdout to capture Docker progress
            process = subprocess.Popen(
                full_cmd, 
                shell=True, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.STDOUT, 
                text=True, 
                cwd=cwd,
                bufsize=1, 
                universal_newlines=True
            )

            # Read output stream
            for line in process.stdout:
                self.log(line)
            
            process.wait()
            if process.returncode != 0:
                raise Exception(f"Command failed: {cmd}")

        except Exception as e:
            raise e

    def install_logic(self):
        pw = self.root_pass.get()
        inst_path = self.install_path.get()
        p_path = self.photos_path.get()
        ext_path = self.ext_lib_path.get()

        if not all([pw, inst_path, p_path, ext_path]):
            messagebox.showerror("Error", "All fields are required.")
            self.btn_install.config(state='normal')
            return

        try:
            # 1. Check Docker
            self.log("Checking for Docker...")
            try:
                self.run_command("docker --version")
                self.log("Docker is already installed.")
            except:
                self.log("Docker not found. Installing (this may take a few minutes)...")
                
                # --- Docker Install ---
                self.log("Downloading Docker installation script...")
                try:
                    urllib.request.urlretrieve("https://get.docker.com", "get-docker.sh")
                except Exception as e:
                    raise Exception(f"Failed to download Docker script: {e}")

                self.log("Running Docker installer...")
                self.run_command("sh get-docker.sh", sudo_pw=pw)
                self.log("Docker installed successfully.")
                
                # Add user to docker group
                user = os.getenv('USER')
                self.log(f"Adding {user} to docker group...")
                self.run_command(f"usermod -aG docker {user}", sudo_pw=pw)
            
            # Ensure Install Directory exists
            if not os.path.exists(inst_path):
                os.makedirs(inst_path)

            # 2. Generate Credentials & Config
            db_password = secrets.token_urlsafe(16)
            
            # 3. Create docker-compose.yml
            compose_content = DOCKER_COMPOSE_TEMPLATE.format(
                PHOTOS_PATH=p_path,
                EXTERNAL_LIB_PATH=ext_path,
                DB_PASSWORD=db_password,
                INSTALL_PATH=inst_path
            )

            # 4. Create .env file
            env_content = ENV_TEMPLATE.format(
                PHOTOS_PATH=p_path,
                DB_PASSWORD=db_password
            )

            self.log(f"Writing configuration files to {inst_path}...")
            
            with open(os.path.join(inst_path, "docker-compose.yml"), "w") as f:
                f.write(compose_content)
            
            with open(os.path.join(inst_path, ".env"), "w") as f:
                f.write(env_content)

            # 5. Pull Images (with logging)
            self.log("-----------------------------------------")
            self.log("Downloading Immich Images...")
            self.log("This may take a while. Please wait...")
            
            # We explicitly pull first to show the download logs
            self.run_live_command("docker compose pull", sudo_pw=pw, cwd=inst_path)
            
            # 6. Start Immich
            self.log("-----------------------------------------")
            self.log("Starting Immich containers...")
            self.run_live_command("docker compose up -d", sudo_pw=pw, cwd=inst_path)

            self.log("-----------------------------------------")
            self.log("SUCCESS! Immich is starting up.")
            self.log("Please wait a few minutes for the database to initialize.")
            self.log("Access Immich at: http://<YOUR_PI_IP>:2283")
            self.log("-----------------------------------------")
            messagebox.showinfo("Success", "Immich has been installed and started!")

        except Exception as e:
            self.log(f"ERROR: {str(e)}")
            messagebox.showerror("Installation Failed", str(e))
        finally:
            self.btn_install.config(state='normal')
            if os.path.exists("get-docker.sh"):
                os.remove("get-docker.sh")

    def start_install(self):
        self.btn_install.config(state='disabled')
        threading.Thread(target=self.install_logic, daemon=True).start()

if __name__ == "__main__":
    root = tk.Tk()
    app = ImmichInstallerApp(root)
    root.mainloop()